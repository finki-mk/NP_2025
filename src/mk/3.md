<img src="../img/logo_mk.png">

# Advanced Programming
## Auditory Exercise 3 (Generic programming, generic functions, generic classes, generic data structures)

#### 1. Кутија

Да се напише генеричка класа кој симулира исцртување на случаен предмет од некоја кутија. Оваа класа треба да се користи за случајно исцртување. На пример, класата може да содржи листа со имиња и избира едно случајно име, или пак листа со броеви за лотарија и избира случајно број. Креирајте метод `add` за додавање објект од соодветниот тип и метод `isEmpty` кој проверува дали кутијата е празна. На крај, имплементирајте метод `drawItem` кој случајно избира објект од кутијата и го враќа како резултат. Ако се обидеме да цртаме со празна кутија се враќа `null`.

Да се напише `main` метод кој ја тестира класата.

**Решение (Box.java)**

```java
package mk.ukim.finki.np.av6;

import java.util.ArrayList;
import java.util.Random;

public class Box<T> {

    private ArrayList<T> items;

    public Box() {
        items = new ArrayList<>();
    }

    public void add(T item) {
        items.add(item);
    }

    public boolean isEmpty() {
        return items.size() == 0;
    }

    public T drawItem() {
        if (isEmpty()) {
            return null;
        }
        Random random = new Random();
        return items.get(random.nextInt(items.size()));
    }

    public static void main(String[] args) {
        Box<String> stringBox = new Box<>();
        stringBox.add("Dexter");
        stringBox.add("Seinfeld");
        stringBox.add("Barney");
        stringBox.add("Sheldon");
        stringBox.add("Costanza");
        stringBox.add("Hank");
        System.out.println(stringBox.drawItem());
        Box<Integer> intBox = new Box<>();
        intBox.add(23);
        intBox.add(15);
        intBox.add(19);
        intBox.add(3);
        intBox.add(92);
        System.out.println(intBox.drawItem());
    }
}
```

---

#### 2. Priority Queue (Ред на чекање со приоритет)

Да се имплементира класа за податочна структура `PriorityQueue` со помош на `ArrayList`. `PriorityQueue` е податочна структура во која секој елемент е придружен заедно со неговиот приоритет (цел број). Приоритет да се дефинира така што оние елементи со најголема вредност имаат повисок приоритет. Класата треба да ги имплементира следните методи:

- `add(item, priority)` - додава нов елемент со асоциран приоритет
- `remove()` - го враќа елементот со најголем приоритет и го брише од редот. Ако редот е празен се враќа `null`.

**Пример:**

```java
q.add("X", 10);
q.add("Y", 1);
q.add("Z", 3);
System.out.println(q.remove()); // Returns X
System.out.println(q.remove()); // Returns Z
System.out.println(q.remove()); // Returns Y
```

Тестирајте го редот со податоци со приоритет во различен редослед (пр., растечки, опаѓачки, мешан). Редот може да се имплементира со линеарно пребарување низ `ArrayList`.

**Решение (PriorityQueue.java)**

```java
package mk.ukim.finki.np.av6;

import java.util.ArrayList;

public class PriorityQueue<T> {
    private ArrayList<T> queue;
    private ArrayList<Integer> priorities;

    public PriorityQueue() {
        queue = new ArrayList<>();
        priorities = new ArrayList<>();
    }

    public void add(T item, int priority) {
        int i;
        for (i = 0; i < priorities.size(); i++) {
            if (priorities.get(i) < priority) {
                break;
            }
        }
        queue.add(i, item);
        priorities.add(i, priority);
    }

    public T remove() {
        if (queue.isEmpty()) {
            return null;
        }
        T item = queue.get(0);
        queue.remove(0);
        priorities.remove(0);
        return item;
    }

    public static void main(String[] args) {
        PriorityQueue<String> pq = new PriorityQueue<String>();
        pq.add("X", 0);
        pq.add("Y", 1);
        pq.add("Z", 3);
        System.out.println(pq.remove()); // Returns X
        System.out.println(pq.remove()); // Returns Z
        System.out.println(pq.remove()); // Returns Y
    }
}
```

---

#### 3. Стандардна девијација (MyMathClass)

Да се напише класа `MyMathClass`, во која ќе се имплементира статички метод `standardDeviation`. Методот како аргумент прима `ArrayList` од тип `T`, каде што `T` е нумерички тип (пр. `Integer`, `Double`, или било која класа која наследува од `java.lang.Number`) и враќа резултат `double` кој претставува стандардната девијација на вредностите во листата.

Формула за стандардна девијација:

σ = sqrt( (1/N) * Σ(xi - μ)² ), каде μ = (1/N) * Σxi

**Решение (MyMathClass.java)**

```java
package mk.ukim.finki.np.av6;

import java.util.ArrayList;

public class MyMathClass {

    public static double standardDeviation(ArrayList<? extends Number> array) {
        double sum = 0;
        for (Number n : array) {
            sum += n.doubleValue();
        }
        double avg = sum / array.size();
        sum = 0;
        for (Number n : array) {
            sum += (avg - n.doubleValue()) * (avg - n.doubleValue());
        }
        return Math.sqrt(sum / array.size());
    }

    public static void main(String[] args) {
        ArrayList<Integer> ints = new ArrayList<>();
        ints.add(1);
        ints.add(10);
        ints.add(20);
        ints.add(30);
        ints.add(40);
        ints.add(50);
        System.out.println(String.format("STD: %.2f",
                MyMathClass.standardDeviation(ints)));
        ArrayList<Double> doubles = new ArrayList<>();
        doubles.add(3.4);
        System.out.println(String.format("STD: %.2f",
                MyMathClass.standardDeviation(doubles)));
    }
}
```

#### 4. ArrayList - Споредба со низи

`ArrayList` е класа од стандардните Java библиотеки која го имплементира интерфејсот `List`.
За разлика од низите, кои имаат фиксна должина откако ќе се креираат, `ArrayList` е објект кој може динамички да се проширува додека програмата се извршува.
Воопшто земено, `ArrayList` ја има истата намена како и низите, но може да ја менува својата должина за време на извршување на програмата. Внатрешно е имплементирана со помош на низа како приватна класна променлива.

**Зошто секогаш да не користиме ArrayList наместо низи?**

* `ArrayList` е помалку ефикасна од низа.
* Не поддржува нотација со големи загради `[]`.
* Основниот тип на `ArrayList` мора да биде класа (или друг референтен тип) — не може да биде примитивен тип како `int`, `float` или `double`.

#### 5. Пример колоквиумска задача со генерици
Имплементирајте ја класата `ExecuteAndSort` со статички генерички метод `execute`. Методот прима два аргументи: листа од споредливи објекти и функција која прима и враќа ист тип на објекти.

Методот враќа резултантна листа од истиот тип на објекти, по трансформацијата направена со дадената функција, сортирана во опаѓачки редослед.

Во `main` функцијата на класата `ExecuteAndSortTest`, во деловите означени со `TODO`, треба да се повика методот `execute` за креираните листи на објекти и да се испечатат резултатите од методот.

```java
package class3.exam;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

class Student implements Comparable<Student> {
    String id;
    List<Integer> grades;

    public Student(String id, List<Integer> grades) {
        this.id = id;
        this.grades = grades;
    }

    public double average() {
        return grades.stream().mapToDouble(i -> i).average().getAsDouble();
    }

    public int getYear() {
        return (24 - Integer.parseInt(id.substring(0, 2)));
    }

    public int totalCourses() {
        return Math.min(getYear() * 10, 40);
    }

    public double labAssistantPoints() {
        return average() * ((double) grades.size() / totalCourses()) * (0.8 + ((getYear() - 1) * 0.2) / 3.0);
    }

    //TODO: implement function
    public static List<Integer> mapGrades(List<Integer> grades) {
        return grades.stream().map(i -> 11 - i).collect(Collectors.toList());
    }

    @Override
    public int compareTo(Student o) {
        return Comparator.comparing(Student::labAssistantPoints)
                         .thenComparing(Student::average)
                         .compare(this, o);
    }

    @Override
    public String toString() {
        return String.format(
                "Student %s (%d year) - %d/%d passed exam, average grade %.2f.\nLab assistant points: %.2f",
                id,
                getYear(),
                grades.size(),
                totalCourses(),
                average(),
                labAssistantPoints()
        );
    }
}

class ExecuteAndSort {

    public static <E extends Comparable> List<E> execute(List<E> elements, Function<E, E> function) {
        return (List<E>) elements
                .stream()
                .map(function::apply)
                .sorted(Comparator.reverseOrder())
                .collect(Collectors.toList());
    }
}

public class ExecuteAndSortTest {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int testCase = Integer.parseInt(sc.nextLine());
        int n = Integer.parseInt(sc.nextLine());

        if (testCase == 1) { // students
            int studentScenario = Integer.parseInt(sc.nextLine());
            List<Student> students = new ArrayList<>();
            while (n > 0) {
                String line = sc.nextLine();
                String[] parts = line.split("\\s+");
                String id = parts[0];
                List<Integer> grades = Arrays.stream(parts).skip(1).map(Integer::parseInt).collect(Collectors.toList());
                students.add(new Student(id, grades));
                --n;
            }

            if (studentScenario == 1) {
                //TODO: transform all students such that their id is converted into a new format adding the suffix
                // "_FCSE" after each id number

                students = ExecuteAndSort.execute(
                        students, (a) -> {
                            a.id = a.id + "_FCSE";
                            return a;
                        }
                );

                System.out.println(students);

            } else {
                //TODO: transform all students such that their grades are mapped into a new system as follows:
                // 10 -> 1
                // 9 -> 2
                // 8 -> 3
                // 7 -> 4
                // 6 -> 5

                students = ExecuteAndSort.execute(
                        students, (a) -> {
                            a.grades = Student.mapGrades(a.grades);
                            return a;
                        }
                );

                System.out.println(students);

            }
        } else { //integers
            List<Integer> integers = new ArrayList<>();
            while (n > 0) {
                integers.add(Integer.parseInt(sc.nextLine()));
                --n;
            }

            //TODO: transform all integers to be 10 times greater than their original value if their original value
            // was less than 100 or 2 times greater otherwise

            integers = ExecuteAndSort.execute(
                    integers, (a) -> {
                        if (a < 100)
                            return 10 * a;
                        return 2 * a;
                    }
            );
            System.out.println(integers);
        }
    }
}
```
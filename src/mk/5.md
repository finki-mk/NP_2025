<img src="../img/logo_mk.png">

# Advanced Programming
## Auditory Exercise 5 (Exercises, introducing maps)

#### 1. Healthy meals
Да се дефинира класа **HealthyMeals** за анализа на исхрана на луѓе врз основа на листа на здрави оброци.
Системот треба да овозможи анализа на тоа колку здрави оброци консумира секоја личност.

Да се имплементира методот:
- public void evaluate(InputStream is, OutputStream os) 
  - чита податоци во овој формат 
    - healthyMeal1 healthyMeal2 healthyMeal3 ...
    - PERSON_ID meal1 meal2 meal3 ...
    - PERSON_ID meal1 meal2 ...
  - Првата линија ги содржи сите здрави оброци.
    Секоја наредна линија ги содржи податоците за една личност: нејзиното ID и имињата на оброците кои ги консумирала.
    За секоја личност треба да се пресмета колку од внесените оброци се здрави, односно колку се појавуваат во листата на здрави оброци.
    Резултатот се печати на излезниот поток, при што сите лица се подредени опаѓачки според бројот на здрави оброци,
    а ако бројот е ист — растечки според PERSON_ID.

- Пример влез
    - salad apple yogurt
    - 101 salad pizza salad soup
    - 102 apple yogurt coffee
    - 103 burger fries

- Пример излез
  - Person ID: 101 (healthy meals: 1)
  - Person ID: 102 (healthy meals: 2)
  - Person ID: 103 (healthy meals: 0)

**Решение**
- https://github.com/atodorovska/np-code-2025/tree/main/src/class5/healthy_meals

#### 2. Airports
Да се имплементира класа **Airports** со цел управување со информации за аеродроми и летови.

---

**public void addAirport(String name, String country, String code, int passengers)**  
Метод за додавање нов аеродром (име, држава, код и број на патници кои ги превезува годишно).  
Аеродромите да се чуваат во мапа `Map<String, Airport>` каде што клуч е кодот на аеродромот.

**public void addFlight(String from, String to, int time, int duration)**  
Метод за додавање нов лет од аеродромот со код `from` кон аеродромот со код `to`.  
Летовите треба да се чуваат во мапа `Map<String, List<Flight>> flightsFrom` каде клуч е кодот на аеродромот на поаѓање.  
Да се користи `computeIfAbsent(...).add(...)` при додавање.  
Од еден аеродром до друг може да постојат повеќе летови.

**public void showFlightsFromAirport(String code)**  
Метод кој ги прикажува сите летови од аеродромот со код `code`.  
Прво се печати името на аеродромот, потоа сите летови подредени најпрво лексикографски според кодот на дестинацијата,  
а потоа според времето на полетување (без користење на `sort()` метод).

**public void showDirectFlightsFromTo(String from, String to)**  
Метод кој ги прикажува сите директни летови од аеродромот `from` до аеродромот `to`, подредени по време на полетување.

**public void showDirectFlightsTo(String to)**  
Метод кој ги прикажува сите директни летови до аеродромот со код `to`, подредени по време на полетување.

---

- Сите летови треба да бидат зачувани и организирани така што не се користи вградено сортирање,  
  туку се вметнуваат на соодветна позиција при додавање.
- Печатењето да следи јасен формат како во тест примерите.

**Решение**
- https://github.com/atodorovska/np-code-2025/tree/main/src/class5/airports

#### 3. Payroll System
Да се имплементира апликација за евиденција на работниот ангажман на вработени во една ИТ компанија.
За таа цел да се имплементира класата **PayrollSystem** во која што ќе се чуваат информации за вработени во компанијата.
Постојат два типа на вработени: **HourlyEmployee** и **FreelanceEmployee**.

- **HourlyEmployee** добиваат плата базирана на вкупниот број на изработени часови.
- **FreelanceEmployee** добиваат плата базирана на поените на тикетите што ги решиле.

---

**PayrollSystem(Map<String, Double> hourlyRateByLevel, Map<String, Double> ticketRateByLevel)**  
Конструктор со два аргументи - мапи.
- Првата мапа означува колку е саатницата за соодветно ниво за вработените што земаат плата по час работа.
- Втората мапа означува колку е платата по поен од тикет за соодветното ниво за фриленсерите.

**void readEmployeesData(InputStream is)**  
Метод за вчитување на податоците за вработените.  
За секој вработен податоците се дадени во нов ред во следниот формат:
- Доколку вработениот е HourlyEmployee: `H;ID;level;hours;`
- Доколку вработениот е FreelanceEmployee: `F;ID;level;ticketPoints1;ticketPoints2;...;ticketPointsN;`

**Map<String, Collection<Employee>> printEmployeesByLevels(OutputStream os, Set<String> levels)**  
Метод кој на излезен поток ќе врати мапа од вработените во нивоата `levels` групирани по нивоа.  
Вработените да бидат сортирани според плата во опаѓачки редослед во рамките на нивото.  
Доколку платата е иста, да се споредуваат според нивото.

**Map<String, Double> totalPayPerEmployee()**  
Метод кој враќа мапа каде клуч е ID-то на вработениот, а вредност е вкупната плата што му следува.  
(Да се користи `merge` или `computeIfAbsent` за собирање на износите.)

---

- Платата на HourlyEmployee се пресметува така што сите часови работа до 40 часа се множат со саатницата за нивото,  
  а сите часови работа над 40 часа, се множат со саатницата зголемена за коефициент 1.5.
- Платата на FreelanceEmployee се пресметува како сума на сите поени * плата по поен за нивото.


**Решение**
- https://github.com/atodorovska/np-code-2025/tree/main/src/class5/payroll_system

#### 4. Add additional Map method to Car task from last exercise

**Решение**
- https://github.com/atodorovska/np-code-2025/tree/main/src/class5/car_map

#### 5. Working with dates and times

**Решение**
- https://github.com/atodorovska/np-code-2025/tree/main/src/class5/dates_and_times

#### 6. Another generic example

Да се имплементира систем за управување со лиценци за медиумски содржини (музика, видео, фотографии итн.) 
кои носат приход преку месечни ројалти.

---

Да се дефинира интерфејс `Quantifiable` со еден метод:
- `double amount()` — ја враќа паричната вредност (износот на месечниот приход).

---

Да се дефинира класа `License` која ги претставува лиценците што ги поседува компанијата.  
Класата треба да ги содржи следните полиња:

- `String title` – наслов на содржината
- `String category` – категорија (на пр. "music", "video", "photo" итн.)
- `String region` – регион (на пр. "EU", "US", "APAC" итн.)
- `int units` – број на користења/стримови/прегледи месечно
- `double ratePerUnit` – износ на приход по единица

- Конструкторот треба да ги иницијализира сите полиња и да спречи негативни вредности за `units` и `ratePerUnit`, како и празни или `null` текстуални вредности.
- Класата треба да го имплементира интерфејсот `Quantifiable`.
- Да го имплементира интерфејсот `Comparable<License>` така што:
    - Се споредува според вкупниот приход (`amount()`), **во опаѓачки редослед**.
    - Ако износот е ист, се споредува по `category` (азбучно).
    - Ако и категоријата е иста, се споредува по `title`.
- Методот `amount()` треба да враќа `units * ratePerUnit`.
- Методот `toString()` да враќа текст во формат:  
  `"Title [category|region] units=X rp=Y total=Z"`

---

Да се дефинира класа `Ledger` која ќе чува список од објекти од било кој тип `T` што имплементира и `Quantifiable` и `Comparable`.

Класата треба да ги содржи следните методи:

1. **Конструктор без аргументи**

2. **`void put(T item)`** – додава нов елемент во колекцијата (не смее да биде `null`).

3. **`Set<....> project(Function<....., ......> mapper)`** –  
   враќа множество од уникатни вредности добиени со примена на дадената функција.

4. **`void forEachIf(Predicate<.....> condition, Consumer<.....> action)`** –  
   извршува дејство `action` врз сите елементи што го исполнуваат условот `condition`.

5. **`double sum()`** – враќа вкупна сума на вредностите (`amount()`) на сите елементи во колекцијата.

6. **`int compareTo(Ledger<....> other)`** – споредува два ledger-а според нивната вкупна вредност (`sum()`), во **опаѓачки редослед** (поголемата сума е „поголема“).
---

**Решение**
- https://github.com/atodorovska/np-code-2025/tree/main/src/class5/generic


<img src="../img/logo_mk.png">

# Advanced Programming
## Auditory Exercise 8 (Concurrent Programming)

### 1. Parallel log processing

Your service write logs in separate files (a file can be related to a microservice and also one file per time interval).

Write a program that will give you the total number of ERROR logs in all files in a given directory.

Compare the time needed to process the files sequentially and concurrently.

```java
package class8.log_processor;

import java.io.IOException;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;

public class LogErrorCounter {

    // ================================
    // Sequential approach
    // ================================
    public static long countErrorsSequential(List<Path> files) {
        long total = 0;
        for (Path file : files) {
            try {
                long count = Files.lines(file)
                        .filter(line -> line.contains("ERROR"))
                        .count();
                total += count;
            } catch (IOException e) {
                System.err.println("Failed to read file: " + file);
            }
        }
        return total;
    }

    // ================================
    // Concurrent approach
    // ================================
    private static class ErrorCounterTask extends Thread {
        private final Path file;
        private long errorCount = 0;

        public ErrorCounterTask(Path file) {
            this.file = file;
        }

        @Override
        public void run() {
            try {
                errorCount = Files.lines(file)
                        .filter(line -> line.contains("ERROR"))
                        .count();
            } catch (IOException e) {
                System.err.println("Failed to read file: " + file);
            }
        }

        public long getErrorCount() {
            return errorCount;
        }
    }

    public static long countErrorsConcurrent(List<Path> files) throws InterruptedException {
        List<ErrorCounterTask> tasks = new ArrayList<>();

        // Create and start threads
        for (Path file : files) {
            ErrorCounterTask task = new ErrorCounterTask(file);
            tasks.add(task);
            task.start();
        }

        // Wait for all threads
        long total = 0;
        for (ErrorCounterTask task : tasks) {
            task.join();
            total += task.getErrorCount();
        }
        return total;
    }

    // ================================
    // Runner with time measurement
    // ================================
    public static void main(String[] args) throws Exception {

        Path logsDir = Paths.get("src/class8/logs"); // <-- adjust if needed

        if (!Files.isDirectory(logsDir)) {
            System.err.println("Directory 'logs' not found!");
            return;
        }

        // Collect all .log files
        List<Path> files = new ArrayList<>();
        try (DirectoryStream<Path> ds = Files.newDirectoryStream(logsDir, "*.log")) {
            for (Path p : ds) files.add(p);
        }

        if (files.isEmpty()) {
            System.out.println("No log files found.");
            return;
        }

        System.out.println("Found " + files.size() + " log files.");
        System.out.println("-------------------------------------------");

        // Sequential measurement
        long startSeq = System.currentTimeMillis();
        long seqTotal = countErrorsSequential(files);
        long endSeq = System.currentTimeMillis();

        System.out.println("Sequential total errors: " + seqTotal);
        System.out.println("Sequential time: " + (endSeq - startSeq) + " ms");
        System.out.println();

        // Concurrent measurement
        long startConc = System.currentTimeMillis();
        long concTotal = countErrorsConcurrent(files);
        long endConc = System.currentTimeMillis();

        System.out.println("Concurrent total errors: " + concTotal);
        System.out.println("Concurrent time: " + (endConc - startConc) + " ms");
        System.out.println();

        // Cross-check correctness
        if (seqTotal == concTotal) {
            System.out.println("CORRECT: Both methods produced the same result.");
        } else {
            System.out.println("WARNING: Results differ! Sequential=" +
                    seqTotal + ", Concurrent=" + concTotal);
        }

        System.out.println("-------------------------------------------");
        System.out.println("Speedup: " + String.format("%.2f",
                (double) (endSeq - startSeq) / (endConc - startConc)) + "x faster");
    }
}

```


### 2. Single large file processing 

Count the frequency of each letter (a-z) in a large text file (e.g., a book).

Implement a concurrent approach where the file is divided into N parts, and each part is processed by a separate thread.

Compare the time taken for sequential and concurrent processing.

```java
package class8.parallel_letter_counter;

import java.io.IOException;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;

public class LetterFrequencyCounter {

    // ============================================
    // Sequential letter counter
    // ============================================
    public static int[] countSequential(String text) {
        int[] counts = new int[26];

        for (char c : text.toCharArray()) {
            if (Character.isLetter(c)) {
                int index = Character.toLowerCase(c) - 'a';
                if (index >= 0 && index < 26) {
                    counts[index]++;
                }
            }
        }

        return counts;
    }

    // ============================================
    // Worker thread for parallel processing
    // ============================================
    private static class LetterCounterWorker extends Thread {
        private final String text; //shared memory
        private final int start;
        private final int end;
        private final int[] localCounts = new int[26]; //local memory

        public LetterCounterWorker(String text, int start, int end) {
            this.text = text;
            this.start = start;
            this.end = end;
        }

        @Override
        public void run() {
            for (int i = start; i < end; i++) {
                char c = text.charAt(i);
                if (Character.isLetter(c)) {
                    int index = Character.toLowerCase(c) - 'a';
                    if (index >= 0 && index < 26) {
                        localCounts[index]++;
                    }
                }
            }
        }

        public int[] getLocalCounts() {
            return localCounts;
        }
    }

    // ============================================
    // Parallel letter counter
    // ============================================
    public static int[] countParallel(String text, int numThreads) throws InterruptedException {
        int length = text.length();
        int chunk = length / numThreads;

        List<LetterCounterWorker> workers = new ArrayList<>();

        for (int i = 0; i < numThreads; i++) {
            int start = i * chunk;
            int end = (i == numThreads - 1) ? length : start + chunk;

            LetterCounterWorker worker = new LetterCounterWorker(text, start, end);
            workers.add(worker);
            worker.start();
        }

        // Combine results
        int[] globalCounts = new int[26];

        for (LetterCounterWorker w : workers) {
            w.join();
            int[] local = w.getLocalCounts();
            for (int i = 0; i < 26; i++) {
                globalCounts[i] += local[i];
            }
        }

        return globalCounts;
    }

    // ============================================
    // Helper → print histogram
    // ============================================
    public static void printCounts(int[] counts) {
        for (int i = 0; i < 26; i++) {
            char letter = (char) ('a' + i);
            System.out.printf("%c: %d%n", letter, counts[i]);
        }
    }

    // ============================================
    // MAIN — loads text, runs sequential & parallel
    // ============================================
    public static void main(String[] args) throws Exception {

        Path filePath = Paths.get("src/class8/large_text.txt");

        if (!Files.exists(filePath)) {
            System.err.println("File 'large_text.txt' not found!");
            return;
        }

        String text = Files.readString(filePath);

        System.out.println("Text length: " + text.length());
        System.out.println("---------------------------------------");

        // ====================================
        // Sequential timing
        // ====================================
        long startSeq = System.currentTimeMillis();
        int[] seqCounts = countSequential(text);
        long endSeq = System.currentTimeMillis();

        System.out.println("Sequential time: " + (endSeq - startSeq) + " ms");

        // ====================================
        // Parallel timing
        // ====================================
        int numThreads = 2;
//                Runtime.getRuntime().availableProcessors();

//        System.out.println(numThreads);

        long startPar = System.currentTimeMillis();
        int[] parCounts = countParallel(text, 4);
        long endPar = System.currentTimeMillis();

        System.out.println("Parallel time (" + numThreads + " threads): " + (endPar - startPar) + " ms");

        // ====================================
        // Compare results
        // ====================================
        boolean same = true;
        for (int i = 0; i < 26; i++) {
            if (seqCounts[i] != parCounts[i]) {
                same = false;
                break;
            }
        }

        if (same)
            System.out.println("CORRECT: Sequential and parallel results match.");
        else
            System.out.println("ERROR: Results do NOT match!");

        System.out.println("---------------------------------------");
        System.out.println("Speedup: " + String.format("%.2f",
                (double) (endSeq - startSeq) / (endPar - startPar)) + "x");
    }
}
```

### 3. API calls

LLMs often take a while to generate a response – several seconds per request.
In the folder `questions/`, you have multiple text files with different prompts about multithreading in Java.
Implement a program that makes multiple API calls to OpenAI's GPT-4o-mini model (in order to generate a response to your prompts) in parallel using multithreading (Executor Service).

Compare the time taken for sequential vs concurrent API calls.

```java
package class8.parallel_api_calls;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;

public class Main {

    private static final String API_KEY = System.getenv("OPENAI_API_KEY");
    private static final String ENDPOINT = "https://api.openai.com/v1/chat/completions";

    public static String extractContent(String json) {

        // Find the `"content":` field AFTER `"message"`
        String messageMarker = "\"message\":";
        int messageIndex = json.indexOf(messageMarker);
        if (messageIndex == -1) return null;

        String contentMarker = "\"content\":";
        int contentIndex = json.indexOf(contentMarker, messageIndex);
        if (contentIndex == -1) return null;

        // Find first quote AFTER "content":
        int startQuote = json.indexOf("\"", contentIndex + contentMarker.length());
        if (startQuote == -1) return null;

        // Find the closing quote
        int endQuote = json.indexOf("\"", startQuote + 1);
        if (endQuote == -1) return null;

        // Extract content
        String result = json.substring(startQuote + 1, endQuote);

        // Handle escaped newlines or quotes if needed
        return result.replace("\\n", "\n").replace("\\\"", "\"");
    }


    // ================================================================
    // MAKE A SINGLE OPENAI REQUEST
    // ================================================================
    public static String callOpenAI(String prompt) throws IOException {
        URL url = new URL(ENDPOINT);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();

        conn.setRequestMethod("POST");
        conn.setRequestProperty("Authorization", "Bearer " + API_KEY);
        conn.setRequestProperty("Content-Type", "application/json");
        conn.setDoOutput(true);

        String body = """
        {
          "model": "gpt-4o-mini",
          "messages": [
            { "role": "system", "content": "You are a helpful assistant that answers questions about multithreading concepts in Java." },
            { "role": "user", "content": "%s" }
          ]
        }
        """.formatted(prompt.replace("\"", "'"));

        try (OutputStream os = conn.getOutputStream()) {
            os.write(body.getBytes(StandardCharsets.UTF_8));
        }

        if (conn.getResponseCode()==200){
            return extractContent(new String(conn.getInputStream().readAllBytes(), StandardCharsets.UTF_8));
        } else {
            return new String(conn.getErrorStream().readAllBytes(), StandardCharsets.UTF_8);
        }
    }

    // ================================================================
    // SEQUENTIAL EXECUTION
    // ================================================================
    public static List<String> runSequential(List<String> prompts) throws IOException {
        List<String> outputs = new ArrayList<>();

        long start = System.currentTimeMillis();
        for (String p : prompts) {
            outputs.add(callOpenAI(p));
        }
        long end = System.currentTimeMillis();

        System.out.println("Sequential time: " + (end - start) + " ms");
        return outputs;
    }

    // ================================================================
    // CONCURRENT EXECUTION
    // ================================================================
    public static List<String> runConcurrent(List<String> prompts, int threadCount) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        List<Future<String>> futures = new ArrayList<>();

        long start = System.currentTimeMillis();

        for (String p : prompts) {
            Callable<String> task = () -> callOpenAI(p);
            futures.add(executor.submit(task));
        }

        List<String> outputs = new ArrayList<>();
        for (Future<String> f : futures) {
            outputs.add(f.get());
        }

        executor.shutdown();
        executor.awaitTermination(1, TimeUnit.MINUTES);

        long end = System.currentTimeMillis();
        System.out.println("Concurrent time (" + threadCount + " threads): " + (end - start) + " ms");

        return outputs;
    }

    // ================================================================
    // MAIN
    // ================================================================
    public static void main(String[] args) throws Exception {

        // Load all text files from /questions directory
        Path promptDir = Paths.get("src/class8/questions");
        if (!Files.exists(promptDir)) {
            System.err.println("Directory 'questions/' not found!");
            return;
        }

        List<String> prompts = new ArrayList<>();
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(promptDir, "*.txt")) {
            for (Path p : stream) {
                prompts.add(Files.readString(p));
            }
        }

        System.out.println("Loaded " + prompts.size() + " prompts.");
        System.out.println("======================================");

        // Sequential
        List<String> sequentialResults = runSequential(prompts);

        System.out.println("Sequential results: " + sequentialResults.stream().collect(Collectors.joining("\n")));

        // Concurrent (using CPU cores)
        int threads = Math.min(prompts.size(), Runtime.getRuntime().availableProcessors());
        List<String> concurrentResults = runConcurrent(prompts, threads);

        System.out.println("Concurrent results: " + concurrentResults.stream().collect(Collectors.joining("\n")));

        System.out.println("======================================");
        System.out.println("Speedup: compare times above manually.");
    }
}

```
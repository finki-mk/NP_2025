<img src="../img/logo_mk.png">

# Advanced programming
## Exercise 1 (Object-Oriented Programming)

### 1. Bank (inheritance, polymorphism and interfaces)

Given are the following five classes:

1. `Bank`

2. `Account`

3. `NonInterestCheckingAccount`

4. `InterestCheckingAccount`

5. `PlatinumCheckingAccount`

as well as an interface called `InterestBearingAccount` which behave as follows:

- In `Bank` a list of all types of accounts is stored, including savings and checking accounts, some of which are subject to interest and some are not. In Bank there is a method `totalAssets` which returns the sum of the balance of all accounts. It also contains a method `addInterest` which calls the `addInterest` method on all accounts that are subject to interest.

- `Account` is an abstract class. Each account stores the name of the account holder, the account number (a sequential number assigned automatically), and the current balance. The class implements a constructor for initializing the data members, methods for accessing the current balance, as well as for adding and subtracting from the current balance.

- The `InterestBearingAccount` interface declares a single method `addInterest` (without parameters and returns nothing - void) which increases the balance with the appropriate interest rate for this type of account.

- `InterestCheckingAccount` is an `Account` which is also an `InterestBearingAccount`. Calling `addInterest` increases the balance by 3%.

- `PlatinumCheckingAccount` is an `InterestCheckingAccount`. Calling `addInterest` increases the balance by double the interest rate for `InterestCheckingAccount` (whatever that may be).

- `NonInterestCheckingAccount` is an `Account` but not an `InterestBearingAccount`. It has no additional functionalities beyond the basic ones from the class Account.

For this task, it is necessary to implement the functionality given in the previous text:

Five of the six mentioned classes form a hierarchy. For these classes, draw this hierarchy.

1. Implement `Account`.

2. Implement `NonInterestCheckingAccount`.

3. Write the `InterestBearingAccount` interface.

4. Implement `Bank`.

5. Implement `InterestCheckingAccount`.

6. Implement `PlatinumCheckingAccount`.

```java
abstract class Account {

    private String holderName;
    private int number;
    private double currentAmount;

    public Account(String holderName, int number, double currentAmount) {
        this.holderName = holderName;
        this.number = number;
        this.currentAmount = currentAmount;
    }

    public double getCurrentAmount() {
        return currentAmount;
    }

    public void addAmount(double amount) {
        currentAmount += amount;
    }

    public void withdrawAmount(double amount) {
        currentAmount -= amount;
    }

}

class NonInterestCheckingAccount extends Account {

    public NonInterestCheckingAccount(String holderName, int number, double currentAmount) {
        super(holderName, number, currentAmount);
    }
}

interface InterestBearingAccount {
    void addInterest();
}

class InterestCheckingAccount
        extends Account implements InterestBearingAccount {

    public static final double INTEREST_RATE = .03; // 3%

    public InterestCheckingAccount(String holderName, int number, double currentAmount) {
        super(holderName, number, currentAmount);
    }

    @Override
    public void addInterest() {
        addAmount(getCurrentAmount() * INTEREST_RATE);
    }

}

class PlatinumCheckingAccount extends Account implements
        InterestBearingAccount {

    public PlatinumCheckingAccount(String holderName, int number, double currentAmount) {
        super(holderName, number, currentAmount);
    }

    @Override
    public void addInterest() {
        addAmount(getCurrentAmount() * InterestCheckingAccount.INTEREST_RATE * 2);
    }

}

class Bank {
    private Account[] accounts;
    private int totalAccounts;
    private int max;

    public Bank(int max) {
        this.totalAccounts = 0;
        this.max = max;
        accounts = new Account[max];
    }

    public void addAccount(Account account) {
        if (totalAccounts == accounts.length) {
            accounts = Arrays.copyOf(accounts, max * 2);
        }
        accounts[totalAccounts++] = account;
    }

    public double totalAssets() {
        double sum = 0;
        for (Account account : accounts) {
            sum += account.getCurrentAmount();
        }
        return sum;
    }

    public void addInterest() {
        for (Account account : accounts) {
            if (account instanceof InterestBearingAccount) {
                InterestBearingAccount iba = (InterestBearingAccount) account;
                iba.addInterest();
            }
        }
    }
}
```

### 2. Inheritance (refactoring)

The following code was designed by J. Hacker for a video game. There is a class `Alien` that represents an alien and a class `AlienPack` that represents a group of aliens and how much damage they can inflict:

```java
class Alien {
    public static final int SNAKE_ALIEN = 0;
    public static final int OGRE_ALIEN = 1;
    public static final int MARSHMALLOW_MAN_ALIEN = 2;
    public int type; // Stores one of the three above types
    public int health; // 0=dead, 100=full strength
    public String name;

    public Alien(int type, int health, String name) {
        this.type = type;
        this.health = health;
        this.name = name;
    }
}

class AlienPack {
    private Alien[] aliens;

    public AlienPack(int numAliens) {
        aliens = new Alien[numAliens];
    }

    public void addAlien(Alien newAlien, int index) {
        aliens[index] = newAlien;
    }

    public Alien[] getAliens() {
        return aliens;
    }

    public int calculateDamage() {
        int damage = 0;
        for (int i = 0; i < aliens.length; i++) {
            if (aliens[i].type == Alien.SNAKE_ALIEN) {
                damage += 10;// Snake does 10 damage
            } else if (aliens[i].type == Alien.OGRE_ALIEN) {
                damage += 6;// Ogre does 6 damage
            } else if (aliens[i].type == Alien.MARSHMALLOW_MAN_ALIEN) {
                damage += 1;
                // Marshmallow Man does 1 damage
            }
        }
        return damage;
    }
}
```

The code is not very object-oriented and does not support encapsulation in the `Alien` class. It should be rewritten so that inheritance is used to represent different types of aliens instead of using the `type` parameter. Also, rewrite the `Alien` class so that it hides the instance variables and add a method `getDamage` which, for each of the derived classes, will return the amount of damage it causes. Finally, rewrite the `calculateDamage` method to use `getDamage` and write a `main` method to test the class.

### 3. Reading from standard input (SI)
#### 3.1 Calculator

Write a program â€” a simple calculator.  
The calculator stores a single number of type `double` named `result`, whose initial value is `0.0`.  
In a loop, the user is allowed to:

- add (`+`)
- subtract (`-`)
- multiply (`*`)
- divide (`/`)

with a second number.  
The result of these operations becomes the new value of `result`.  
Calculations end when the user enters `R` (uppercase or lowercase) for `result`.  
Then the user can start a new calculation from the beginning or end the program (`Y/N`).

If the user enters an operator other than `+`, `-`, `*`, or `/`, then an exception `UnknownOperatorException` is thrown, and a new input is requested.

_Example of input data format:_
```bash
Calculator is on.
result = 0.0
+5
result + 5.0 = 5.0
new result = 5.0
* 2.2
result * 2.2 = 11.0
updated result = 11.0
% 10
% is an unknown operation.
Reenter, your last line:
* 0.1
result * 0.1 = 1.1
updated result = 1.1
r
Final result = 1.1
Again? (y/n)
yes
result = 0.0
+10
result + 10.0 = 10.0
new result = 10.0
/2
result / 2.0 = 5.0
updated result = 5.0
r
Final result = 5.0
Again? (y/n)
N
End of Program
```

_Solution:_
```java
class Calculator {
    private double result;
    private static final char PLUS = '+';
    private static final char MINUS = '-';
    private static final char MULTIPLY = '*';
    private static final char DIVIDE = '/';

    public Calculator() {
        result = 0;
    }

    public String init() {
        return String.format("result = %f", result);
    }

    public double getResult() {
        return result;
    }

    public String execute(char operator, double value)
            throws UnknownOperatorException {

        if (operator == PLUS) {
            result += value;
        } else if (operator == MINUS) {
            result -= value;
        } else if (operator == MULTIPLY) {
            result *= value;
        } else if (operator == DIVIDE) {
            result /= value;
        } else {
            throw new UnknownOperatorException(operator);
        }
        return String.format("result %c %f = %f", operator, value, result);
    }

    class UnknownOperatorException extends Exception {
        public UnknownOperatorException(char operator) {
            super(String.format("%c is unknown operation", operator));
        }
    }

    @Override
    public String toString() {
        return String.format("updated result = %f", result);
    }

}

public class CalculatorTest {
    static final char RESULT = 'r';

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while (true) {
            Calculator calculator = new Calculator();
            System.out.println(calculator.init());
            while (true) {
                String line = scanner.nextLine();
                char choice = getCharLower(line);
                if (choice == RESULT) {
                    System.out.println(String.format("final result = %f", calculator.getResult()));
                    break;
                }
                String[] parts = line.split("\\s+");
                char operator = parts[0].charAt(0);
                double value = Double.parseDouble(parts[1]);
                try {
                    String result = calculator.execute(operator, value);
                    System.out.println(result);
                    System.out.println(calculator);
                } catch (Calculator.UnknownOperatorException e) {
                    System.out.println(e.getMessage());
                }
            }
            System.out.println("(Y/N)");
            String line = scanner.nextLine();
            char choice = getCharLower(line);
            if (choice == 'n') {
                break;
            }
        }
    }

    static char getCharLower(String line) {
        if (line.trim().length() > 0) {
            return Character.toLowerCase(line.charAt(0));
        }
        return '?';
    }
}
```
<img src="../img/logo_mk.png">

# Advanced Programming
## Auditory Exercise 3 (Generic programming, generic functions, generic classes, generic data structures)

#### 1. Box

Write a generic class that simulates drawing a random item from a box. This class should be used for random selection. For example, the class can contain a list of names and choose one randomly, or a list of lottery numbers and pick one at random. Create a method `add` to add an object of the appropriate type and a method `isEmpty` that checks whether the box is empty. Finally, implement a method `drawItem` that randomly selects an object from the box and returns it as a result. If we try to draw from an empty box, it should return `null`.

Write a `main` method that tests the class.

**Solution (Box.java)**

```java
package mk.ukim.finki.np.av6;

import java.util.ArrayList;
import java.util.Random;

public class Box<T> {

    private ArrayList<T> items;

    public Box() {
        items = new ArrayList<>();
    }

    public void add(T item) {
        items.add(item);
    }

    public boolean isEmpty() {
        return items.size() == 0;
    }

    public T drawItem() {
        if (isEmpty()) {
            return null;
        }
        Random random = new Random();
        return items.get(random.nextInt(items.size()));
    }

    public static void main(String[] args) {
        Box<String> stringBox = new Box<>();
        stringBox.add("Dexter");
        stringBox.add("Seinfeld");
        stringBox.add("Barney");
        stringBox.add("Sheldon");
        stringBox.add("Costanza");
        stringBox.add("Hank");
        System.out.println(stringBox.drawItem());
        Box<Integer> intBox = new Box<>();
        intBox.add(23);
        intBox.add(15);
        intBox.add(19);
        intBox.add(3);
        intBox.add(92);
        System.out.println(intBox.drawItem());
    }
}
```

---

#### 2. Priority Queue 

Implement a class for the data structure `PriorityQueue` using `ArrayList`. A `PriorityQueue` is a data structure in which each element is associated with its priority (an integer). The priority should be defined so that the elements with the highest value have the highest priority.

The class should implement the following methods:

* `add(item, priority)` – adds a new element with the associated priority.
* `remove()` – returns the element with the highest priority and removes it from the queue. If the queue is empty, it returns `null`.

**Example:**

```java
q.add("X", 10);
q.add("Y", 1);
q.add("Z", 3);
System.out.println(q.remove()); // Returns X
System.out.println(q.remove()); // Returns Z
System.out.println(q.remove()); // Returns Y
```

Test the queue with data that has priorities in different orders (e.g., ascending, descending, or mixed). The queue can be implemented using a linear search through the `ArrayList`.

**Solution (PriorityQueue.java)**

```java
package mk.ukim.finki.np.av6;

import java.util.ArrayList;

public class PriorityQueue<T> {
    private ArrayList<T> queue;
    private ArrayList<Integer> priorities;

    public PriorityQueue() {
        queue = new ArrayList<>();
        priorities = new ArrayList<>();
    }

    public void add(T item, int priority) {
        int i;
        for (i = 0; i < priorities.size(); i++) {
            if (priorities.get(i) < priority) {
                break;
            }
        }
        queue.add(i, item);
        priorities.add(i, priority);
    }

    public T remove() {
        if (queue.isEmpty()) {
            return null;
        }
        T item = queue.get(0);
        queue.remove(0);
        priorities.remove(0);
        return item;
    }

    public static void main(String[] args) {
        PriorityQueue<String> pq = new PriorityQueue<String>();
        pq.add("X", 0);
        pq.add("Y", 1);
        pq.add("Z", 3);
        System.out.println(pq.remove()); // Returns X
        System.out.println(pq.remove()); // Returns Z
        System.out.println(pq.remove()); // Returns Y
    }
}
```

---

#### 3. Standard deviation (MyMathClass)

Write a class `MyMathClass` that implements a static method `standardDeviation`. The method takes as an argument an `ArrayList` of type `T`, where `T` is a numeric type (e.g., `Integer`, `Double`, or any class that extends `java.lang.Number`), and returns a `double` value representing the standard deviation of the values in the list.

Formula for standard deviation:

σ = sqrt( (1/N) * Σ(xi - μ)² ), where μ = (1/N) * Σxi

**Solution (MyMathClass.java)**

```java
package mk.ukim.finki.np.av6;

import java.util.ArrayList;

public class MyMathClass {

    public static double standardDeviation(ArrayList<? extends Number> array) {
        double sum = 0;
        for (Number n : array) {
            sum += n.doubleValue();
        }
        double avg = sum / array.size();
        sum = 0;
        for (Number n : array) {
            sum += (avg - n.doubleValue()) * (avg - n.doubleValue());
        }
        return Math.sqrt(sum / array.size());
    }

    public static void main(String[] args) {
        ArrayList<Integer> ints = new ArrayList<>();
        ints.add(1);
        ints.add(10);
        ints.add(20);
        ints.add(30);
        ints.add(40);
        ints.add(50);
        System.out.println(String.format("STD: %.2f",
                MyMathClass.standardDeviation(ints)));
        ArrayList<Double> doubles = new ArrayList<>();
        doubles.add(3.4);
        System.out.println(String.format("STD: %.2f",
                MyMathClass.standardDeviation(doubles)));
    }
}
```

#### 4. ArrayList - Comparison with arrays

`ArrayList` is a class from the standard Java libraries that implements the `List` interface. 
Unlike arrays, which have a fixed length once created, an `ArrayList` is an object that can grow dynamically while the program is running. 
In general, `ArrayList` serves the same purpose as arrays, but it can change its length during program execution. It is implemented internally using an array as a private class variable.

Why don’t we always use ArrayList instead of arrays?
- ArrayList is less efficient than an array.
- It does not support square bracket notation [].
- The base type of an ArrayList must be a class (or another reference type) — it cannot be a primitive type like int, float, or double.


#### 5. Example exam task using generics
Implement the class ExecuteAndSort with a static generic method execute. The method takes two arguments: a list of comparable objects and a function that takes and returns the same type of objects.

The method returns a result list of the same type of objects, after the transformation done by the provided function, sorted in descending order.

In the main function of the ExecuteAndSort Test class, in the parts marked with TODO, the execute method needs to be called for the created lists of objects, and the results of the method should be printed.

```java
package class3.exam;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

class Student implements Comparable<Student> {
    String id;
    List<Integer> grades;

    public Student(String id, List<Integer> grades) {
        this.id = id;
        this.grades = grades;
    }

    public double average() {
        return grades.stream().mapToDouble(i -> i).average().getAsDouble();
    }

    public int getYear() {
        return (24 - Integer.parseInt(id.substring(0, 2)));
    }

    public int totalCourses() {
        return Math.min(getYear() * 10, 40);
    }

    public double labAssistantPoints() {
        return average() * ((double) grades.size() / totalCourses()) * (0.8 + ((getYear() - 1) * 0.2) / 3.0);
    }

    //TODO: implement function
    public static List<Integer> mapGrades(List<Integer> grades) {
        return grades.stream().map(i -> 11 - i).collect(Collectors.toList());
    }

    @Override
    public int compareTo(Student o) {
        return Comparator.comparing(Student::labAssistantPoints)
                         .thenComparing(Student::average)
                         .compare(this, o);
    }

    @Override
    public String toString() {
        return String.format(
                "Student %s (%d year) - %d/%d passed exam, average grade %.2f.\nLab assistant points: %.2f",
                id,
                getYear(),
                grades.size(),
                totalCourses(),
                average(),
                labAssistantPoints()
        );
    }
}

class ExecuteAndSort {

    public static <E extends Comparable> List<E> execute(List<E> elements, Function<E, E> function) {
        return (List<E>) elements
                .stream()
                .map(function::apply)
                .sorted(Comparator.reverseOrder())
                .collect(Collectors.toList());
    }
}

public class ExecuteAndSortTest {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int testCase = Integer.parseInt(sc.nextLine());
        int n = Integer.parseInt(sc.nextLine());

        if (testCase == 1) { // students
            int studentScenario = Integer.parseInt(sc.nextLine());
            List<Student> students = new ArrayList<>();
            while (n > 0) {
                String line = sc.nextLine();
                String[] parts = line.split("\\s+");
                String id = parts[0];
                List<Integer> grades = Arrays.stream(parts).skip(1).map(Integer::parseInt).collect(Collectors.toList());
                students.add(new Student(id, grades));
                --n;
            }

            if (studentScenario == 1) {
                //TODO: transform all students such that their id is converted into a new format adding the suffix
                // "_FCSE" after each id number

                students = ExecuteAndSort.execute(
                        students, (a) -> {
                            a.id = a.id + "_FCSE";
                            return a;
                        }
                );

                System.out.println(students);

            } else {
                //TODO: transform all students such that their grades are mapped into a new system as follows:
                // 10 -> 1
                // 9 -> 2
                // 8 -> 3
                // 7 -> 4
                // 6 -> 5

                students = ExecuteAndSort.execute(
                        students, (a) -> {
                            a.grades = Student.mapGrades(a.grades);
                            return a;
                        }
                );

                System.out.println(students);

            }
        } else { //integers
            List<Integer> integers = new ArrayList<>();
            while (n > 0) {
                integers.add(Integer.parseInt(sc.nextLine()));
                --n;
            }

            //TODO: transform all integers to be 10 times greater than their original value if their original value
            // was less than 100 or 2 times greater otherwise

            integers = ExecuteAndSort.execute(
                    integers, (a) -> {
                        if (a < 100)
                            return 10 * a;
                        return 2 * a;
                    }
            );
            System.out.println(integers);
        }
    }
}
```
<img src="../img/logo_mk.png">

# Advanced Programming
## Auditory Exercise 10 (Design patterns)

### Composite

Composite is a structural design pattern that lets you compose objects into tree structures and then work with these structures as if they were individual objects.

<img src="../img/composite.png">

#### File System

You are required to define an application for a simple file system in which objects representing files/directories are stored (objects that implement the `IFile` interface).

Declare the `IFile` interface with appropriate methods so that each file/directory has the following characteristics:

- Access to its name (`String getFileName()`)

- Ability to obtain its size as `long` (`long getFileSize()`)

- Ability to obtain a `String` representation of the file (`String getFileInfo(???)`)

- Ability to sort the file if it is a collection of files, according to the sizes of the files it contains (`void sortBySize()`)

- Ability to compute the size of the largest regular file within the file/directory (`findLargestFile()`)

There are two types of files:

- `File` (regular file)

- `Folder` (directory/folder)

Both classes must implement the `IFile` interface.

For a `File`, information about its name and size (as `long`) is stored.

In the `Folder` class, the same information as for `File` is stored, and additionally, a list of files (both regular files and directories) is maintained. For this class, implement the following method:

- `void addFile(IFile file)` – a method for adding any type of file to the list of files.

If a file with the same name as the file being added already exists, an exception of type `FileNameExistsException` should be thrown, passing the name that already exists.

In both classes, implement all methods declared in the `IFile` interface, taking into account the following rules:

- The size of a `Folder` is the sum of the sizes of all files (regular files or directories) it contains.
- When generating the `String` representation of directories, files, and subdirectories within a directory, they should be indented with a tab character (`"\t"`).
- The `String` representation of a regular file is:  
  `File name [file name right-aligned in 10 spaces] File size: [file size right-aligned in 10 spaces]`
- The `String` representation of a directory is:  
  `Folder name [directory name right-aligned in 10 spaces] Folder size: [directory size right-aligned in 10 spaces]`
- Sorting is possible only within a directory, where all files in that directory must be sorted by size in ascending order.
- The method `getLargestFile()` should return the size of the largest regular file within the file/directory where it is invoked.
- When the method `sortBySize()` is called on a directory, it should also be invoked on all of its subdirectories.

Define a class `FileSystem` which stores only one directory (`rootDirectory`). For this class, implement:

- A default constructor `FileSystem()`
- `void addFile(IFile file)` – a method for adding any type of file to the root directory.
- `long findLargestFile()` – a method that returns the size of the largest (regular) file in the root directory.
- `void sortBySize()` – a method that sorts the files in the root directory (both regular files and directories) by their size within the root directory in ascending order.


```java

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;



interface IFile extends Comparable<IFile> {

    String getFileName();

    long getFileSize();

    String getFileInfo(int indent);

    void sortBySize();

    long findLargestFile();

}

class IndentPrinter {
    public static String printIndent(int indentLevel) {
        return IntStream.range(0, indentLevel)
                .mapToObj(i -> "    ")
                .collect(Collectors.joining());
    }
}

class FileNameExistsException extends Exception {

    FileNameExistsException(String fileName, String folderName) {
        super(String.format("There is already a file named %s in the folder %s",
                fileName,
                folderName)
        );
    }
}

class File implements IFile {

    protected String fileName;
    protected long fileSize;

    public File(String fileName, long fileSize) {
        this.fileName = fileName;
        this.fileSize = fileSize;
    }

    public File(String fileName) {
        this.fileName = fileName;
        this.fileSize = 0L;
    }

    @Override
    public String getFileName() {
        return fileName;
    }

    @Override
    public long getFileSize() {
        return fileSize;
    }

    @Override
    public String getFileInfo(int indent) {
        return String.format("%sFile name: %10s File size: %10d\n",
                IndentPrinter.printIndent(indent),
                getFileName(),
                getFileSize());
    }

    @Override
    public void sortBySize() {
        return ;
    }

    @Override
    public long findLargestFile() {
        return this.fileSize;
    }

    @Override
    public int compareTo(IFile iFile) {
        return Long.compare(this.getFileSize(),iFile.getFileSize());
    }
}

class Folder extends File implements IFile {

    List<IFile> files;

    public Folder(String fileName) {
        super(fileName);
        files = new ArrayList<>();
    }

    private boolean checkNameExistence(String filename) {
        return files.stream()
                .map(IFile::getFileName)
                .anyMatch(name -> name.equals(filename));
    }

    public void addFile (IFile file) throws FileNameExistsException {
        if (checkNameExistence(file.getFileName())) {
            throw new FileNameExistsException(file.getFileName(), this.fileName);
        }

        files.add(file);
    }

    @Override
    public String getFileName() {
        return this.fileName;
    }

    @Override
    public long getFileSize() {
        return files.stream().mapToLong(IFile::getFileSize).sum();
    }

    @Override
    public String getFileInfo(int indent) {
        StringBuilder sb = new StringBuilder();

        sb.append(String.format("%sFolder name: %10s Folder size: %10d\n",
                IndentPrinter.printIndent(indent),
                fileName,
                this.getFileSize()));

        files.stream().forEach(file -> sb.append(file.getFileInfo(indent + 1)));

        return sb.toString();
    }


    @Override
    public long findLargestFile() {

        OptionalLong largestHere = files.stream().mapToLong(IFile::findLargestFile).max();

       if (largestHere.isPresent())
            return largestHere.getAsLong();
        else
            return 0L;
    }

    public void sortBySize() {

        Comparator<IFile> iFileComparator = Comparator.comparingLong(IFile::getFileSize);
        files.sort(iFileComparator);

        files.forEach(IFile::sortBySize);
    }
}

class FileSystem {
    Folder root;

    FileSystem() {
        root = new Folder("root");
    }

    void addFile (IFile file) throws FileNameExistsException {
        root.addFile(file);
    }

    long findLargestFile() {
        return root.findLargestFile();
    }

    void sortBySize () {
        root.sortBySize();
    }

    @Override
    public String toString() {
        return this.root.getFileInfo(0);
    }
}


public class FileSystemTest {

    public static Folder readFolder (Scanner sc)  {

        Folder folder = new Folder(sc.nextLine());
        int totalFiles = Integer.parseInt(sc.nextLine());

        for (int i=0;i<totalFiles;i++) {
            String line = sc.nextLine();

            if (line.startsWith("0")) {
                String fileInfo = sc.nextLine();
                String [] parts = fileInfo.split("\\s+");
                try {
                    folder.addFile(new File(parts[0], Long.parseLong(parts[1])));
                } catch (FileNameExistsException e) {
                    System.out.println(e.getMessage());
                }
            }
            else {
                try {
                    folder.addFile(readFolder(sc));
                } catch (FileNameExistsException e) {
                    System.out.println(e.getMessage());
                }
            }
        }

        return folder;
    }

    public static void main(String[] args)  {

        //file reading from input

        Scanner sc = new Scanner (System.in);

        System.out.println("===READING FILES FROM INPUT===");
        FileSystem fileSystem = new FileSystem();
        try {
            fileSystem.addFile(readFolder(sc));
        } catch (FileNameExistsException e) {
            System.out.println(e.getMessage());
        }

        System.out.println("===PRINTING FILE SYSTEM INFO===");
        System.out.println(fileSystem.toString());

        System.out.println("===PRINTING FILE SYSTEM INFO AFTER SORTING===");
        fileSystem.sortBySize();
        System.out.println(fileSystem.toString());

        System.out.println("===PRINTING THE SIZE OF THE LARGEST FILE IN THE FILE SYSTEM===");
        System.out.println(fileSystem.findLargestFile());
    }
}

```

### Decorator

Decorator is a structural design pattern that lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.

<img src="../img/decorator.png">

#### Coffee order

Implement a simple coffee ordering system.

There are two base coffee types: `Espresso` and `BrewedCoffee`.
Each coffee has a description and a price.

A coffee order can be extended with additional ingredients:

- RegularMilk
- OatMilk
- Cream

Each added ingredient must:

- Modify the description of the coffee order
- Increase the total price by a fixed amount

It must be possible to:

- Add multiple ingredients to the same coffee order
- Combine ingredients in any order
- Create coffee orders dynamically at runtime


#####  Solution without design pattern and without proper OOP design
```java
import java.util.ArrayList;
import java.util.List;

/* =========================
   Base coffee type
   ========================= */
enum BaseCoffeeType {
    ESPRESSO,
    BREWED
}

/* =========================
   Ingredient type
   ========================= */
enum IngredientType {
    REGULAR_MILK,
    OAT_MILK,
    CREAM
}

/* =========================
   CoffeeOrder class
   ========================= */
class CoffeeOrder {

    private BaseCoffeeType baseCoffee;
    private List<IngredientType> ingredients;

    public CoffeeOrder(BaseCoffeeType baseCoffee) {
        this.baseCoffee = baseCoffee;
        this.ingredients = new ArrayList<>();
    }

    public void addIngredient(IngredientType ingredient) {
        ingredients.add(ingredient);
    }

    public double getPrice() {
        double price;

        if (baseCoffee == BaseCoffeeType.ESPRESSO) {
            price = 1.50;
        } else {
            price = 1.20;
        }

        for (IngredientType ingredient : ingredients) {
            if (ingredient == IngredientType.REGULAR_MILK) {
                price += 0.30;
            } else if (ingredient == IngredientType.OAT_MILK) {
                price += 0.50;
            } else if (ingredient == IngredientType.CREAM) {
                price += 0.40;
            }
        }

        return price;
    }

    public String getDescription() {
        String description;

        if (baseCoffee == BaseCoffeeType.ESPRESSO) {
            description = "Espresso";
        } else {
            description = "Brewed Coffee";
        }

        for (IngredientType ingredient : ingredients) {
            if (ingredient == IngredientType.REGULAR_MILK) {
                description += ", Regular Milk";
            } else if (ingredient == IngredientType.OAT_MILK) {
                description += ", Oat Milk";
            } else if (ingredient == IngredientType.CREAM) {
                description += ", Cream";
            }
        }

        return description;
    }
}

/* =========================
   Main class
   ========================= */
public class CoffeeShop {

    public static void main(String[] args) {

        CoffeeOrder order1 = new CoffeeOrder(BaseCoffeeType.ESPRESSO);
        order1.addIngredient(IngredientType.REGULAR_MILK);
        order1.addIngredient(IngredientType.CREAM);

        System.out.println(order1.getDescription());
        System.out.println("Price: " + order1.getPrice());

        System.out.println();

        CoffeeOrder order2 = new CoffeeOrder(BaseCoffeeType.BREWED);
        order2.addIngredient(IngredientType.OAT_MILK);

        System.out.println(order2.getDescription());
        System.out.println("Price: " + order2.getPrice());
    }
}

```

##### Solution with OOP design (inheritance and polymorphism)
```java
/* =========================
   Base abstraction
   ========================= */
abstract class Coffee {
    abstract String getDescription();
    abstract double getPrice();
}

/* =========================
   Base coffees
   ========================= */
class Espresso extends Coffee {
    @Override
    String getDescription() {
        return "Espresso";
    }

    @Override
    double getPrice() {
        return 1.50;
    }
}

class BrewedCoffee extends Coffee {
    @Override
    String getDescription() {
        return "Brewed Coffee";
    }

    @Override
    double getPrice() {
        return 1.20;
    }
}

/* =========================
   Espresso combinations
   ========================= */
class EspressoWithRegularMilk extends Coffee {
    @Override
    String getDescription() {
        return "Espresso, Regular Milk";
    }

    @Override
    double getPrice() {
        return 1.80;
    }
}

class EspressoWithOatMilk extends Coffee {
    @Override
    String getDescription() {
        return "Espresso, Oat Milk";
    }

    @Override
    double getPrice() {
        return 2.00;
    }
}

class EspressoWithCream extends Coffee {
    @Override
    String getDescription() {
        return "Espresso, Cream";
    }

    @Override
    double getPrice() {
        return 1.90;
    }
}

/* =========================
   Espresso with two extras
   ========================= */
class EspressoWithRegularMilkAndCream extends Coffee {
    @Override
    String getDescription() {
        return "Espresso, Regular Milk, Cream";
    }

    @Override
    double getPrice() {
        return 2.20;
    }
}

class EspressoWithOatMilkAndCream extends Coffee {
    @Override
    String getDescription() {
        return "Espresso, Oat Milk, Cream";
    }

    @Override
    double getPrice() {
        return 2.40;
    }
}

/* =========================
   Brewed coffee combinations
   ========================= */
class BrewedCoffeeWithRegularMilk extends Coffee {
    @Override
    String getDescription() {
        return "Brewed Coffee, Regular Milk";
    }

    @Override
    double getPrice() {
        return 1.50;
    }
}

class BrewedCoffeeWithOatMilk extends Coffee {
    @Override
    String getDescription() {
        return "Brewed Coffee, Oat Milk";
    }

    @Override
    double getPrice() {
        return 1.70;
    }
}

class BrewedCoffeeWithCream extends Coffee {
    @Override
    String getDescription() {
        return "Brewed Coffee, Cream";
    }

    @Override
    double getPrice() {
        return 1.60;
    }
}

/* =========================
   Main class
   ========================= */
public class CoffeeShop {

    public static void main(String[] args) {

        Coffee c1 = new EspressoWithRegularMilkAndCream();
        System.out.println(c1.getDescription());
        System.out.println("Price: " + c1.getPrice());

        System.out.println();

        Coffee c2 = new BrewedCoffeeWithOatMilk();
        System.out.println(c2.getDescription());
        System.out.println("Price: " + c2.getPrice());
    }
}

```

##### Solution with design patterns 

```java
// =======================
// Component
// =======================
interface Coffee {
    String getDescription();
    double getPrice();
}

// =======================
// Concrete Components
// =======================
class Espresso implements Coffee {

    @Override
    public String getDescription() {
        return "Espresso";
    }

    @Override
    public double getPrice() {
        return 1.50;
    }
}

class BrewedCoffee implements Coffee {

    @Override
    public String getDescription() {
        return "Brewed Coffee";
    }

    @Override
    public double getPrice() {
        return 1.20;
    }
}

// =======================
// Decorator
// =======================
abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;

    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
}

// =======================
// Concrete Decorators
// =======================
class RegularMilk extends CoffeeDecorator {

    public RegularMilk(Coffee coffee) {
        super(coffee);
    }

    @Override
    public String getDescription() {
        return coffee.getDescription() + ", Regular Milk";
    }

    @Override
    public double getPrice() {
        return coffee.getPrice() + 0.30;
    }
}

class OatMilk extends CoffeeDecorator {

    public OatMilk(Coffee coffee) {
        super(coffee);
    }

    @Override
    public String getDescription() {
        return coffee.getDescription() + ", Oat Milk";
    }

    @Override
    public double getPrice() {
        return coffee.getPrice() + 0.50;
    }
}

class Cream extends CoffeeDecorator {

    public Cream(Coffee coffee) {
        super(coffee);
    }

    @Override
    public String getDescription() {
        return coffee.getDescription() + ", Cream";
    }

    @Override
    public double getPrice() {
        return coffee.getPrice() + 0.40;
    }
}

// =======================
// Main class
// =======================
public class CoffeeShop {

    public static void main(String[] args) {

        Coffee order1 = new Espresso();
        order1 = new RegularMilk(order1);
        order1 = new Cream(order1);

        System.out.println(order1.getDescription());
        System.out.println("Price: " + order1.getPrice());

        System.out.println();

        Coffee order2 = new BrewedCoffee();
        order2 = new OatMilk(order2);

        System.out.println(order2.getDescription());
        System.out.println("Price: " + order2.getPrice());
    }
}

```

#### Tasks management system


Write a class `TaskManager` that will be used to manage tasks for a given user.  
The following methods should be implemented in the class:

- `readTasks(InputStream inputStream)` – a method for loading the user’s tasks, where each task is given in the following format:  
  `[category][task_name],[description],[deadline],[priority]`  

  The deadline and the priority are **optional fields**.

  It must not be allowed for a task to have a deadline **after 02.06.2020**.  
  In such a case, an exception of type `DeadlineNotValidException` should be thrown.  
  The exception must be caught at an appropriate place so that the loading of the remaining tasks is **not interrupted**.

- `void printTasks(OutputStream os, boolean includePriority, boolean includeCategory)` – a method for printing the tasks.

  - If `includeCategory` is `true`, tasks should be printed **grouped by category**; otherwise, all entered tasks are printed together.
  - If `includePriority` is `true`, tasks should be printed **sorted by priority** (where `1` is the highest priority).  
    Tasks that do not have a priority or have the same priority should be additionally sorted in **ascending order by the time distance between the deadline and the current date**, meaning tasks with deadlines closest to today are printed first.
  - If `includePriority` is `false`, tasks are printed only in **ascending order by the time distance between the deadline and the current date**.

When printing tasks, use the **default `toString` implementation** (if working in IntelliJ), taking care that the **variable names are correct**.

**Bonus:** Use software design patterns for representing tasks and for their creation.
    
#### Solution without design pattern
```java
import java.io.*;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

/* =========================
   Exception
   ========================= */
class DeadlineNotValidException extends Exception {
    public DeadlineNotValidException(LocalDateTime deadline) {
        super(String.format("The deadline %s is not valid", deadline));
    }
}

/* =========================
   Task class (no decorators)
   ========================= */
class Task {

    String category;
    String name;
    String description;
    LocalDateTime deadline;   // can be null
    Integer priority;         // can be null

    public Task(String category, String name, String description,
                LocalDateTime deadline, Integer priority) {
        this.category = category;
        this.name = name;
        this.description = description;
        this.deadline = deadline;
        this.priority = priority;
    }

    public String getCategory() {
        return category;
    }

    public LocalDateTime getDeadline() {
        return deadline != null ? deadline : LocalDateTime.MAX;
    }

    public int getPriority() {
        return priority != null ? priority : Integer.MAX_VALUE;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("Task{");
        sb.append("name='").append(name).append('\'');
        sb.append(", description='").append(description).append('\'');

        if (deadline != null) {
            sb.append(", deadline=").append(deadline);
        }
        if (priority != null) {
            sb.append(", priority=").append(priority);
        }

        sb.append('}');
        return sb.toString();
    }
}

/* =========================
   TaskManager
   ========================= */
class TaskManager {

    private Map<String, List<Task>> tasks;

    public TaskManager() {
        tasks = new TreeMap<>();
    }

    public void readTasks(InputStream inputStream) {
        BufferedReader br = new BufferedReader(new InputStreamReader(inputStream));

        br.lines().forEach(line -> {
            try {
                Task task = parseTask(line);
                tasks.computeIfAbsent(task.getCategory(), k -> new ArrayList<>())
                     .add(task);
            } catch (DeadlineNotValidException e) {
                System.out.println(e.getMessage());
            }
        });
    }

    private Task parseTask(String line) throws DeadlineNotValidException {
        String[] parts = line.split(",");

        String category = parts[0];
        String name = parts[1];
        String description = parts[2];

        LocalDateTime deadline = null;
        Integer priority = null;

        if (parts.length >= 4) {
            try {
                priority = Integer.parseInt(parts[3]);
            } catch (NumberFormatException e) {
                deadline = LocalDateTime.parse(parts[3]);
                checkDeadline(deadline);
            }
        }

        if (parts.length == 5) {
            deadline = LocalDateTime.parse(parts[3]);
            checkDeadline(deadline);
            priority = Integer.parseInt(parts[4]);
        }

        return new Task(category, name, description, deadline, priority);
    }

    private void checkDeadline(LocalDateTime deadline) throws DeadlineNotValidException {
        LocalDateTime limit = LocalDateTime.of(2020, 6, 2, 23, 59, 59);
        if (deadline.isAfter(limit)) {
            throw new DeadlineNotValidException(deadline);
        }
    }

    public void printTasks(OutputStream os, boolean includePriority, boolean includeCategory) {
        PrintWriter pw = new PrintWriter(os);

        Comparator<Task> priorityComparator =
                Comparator.comparing(Task::getPriority)
                          .thenComparing(t ->
                                  Duration.between(LocalDateTime.now(), t.getDeadline()));

        Comparator<Task> timeComparator =
                Comparator.comparing(t ->
                        Duration.between(LocalDateTime.now(), t.getDeadline()));

        Comparator<Task> comparator =
                includePriority ? priorityComparator : timeComparator;

        if (includeCategory) {
            tasks.forEach((category, list) -> {
                pw.println(category.toUpperCase());
                list.stream()
                    .sorted(comparator)
                    .forEach(pw::println);
            });
        } else {
            tasks.values().stream()
                 .flatMap(Collection::stream)
                 .sorted(comparator)
                 .forEach(pw::println);
        }

        pw.flush();
    }
}

/* =========================
   Main
   ========================= */
public class TasksManagerTest {

    public static void main(String[] args) {

        TaskManager manager = new TaskManager();

        System.out.println("Tasks reading");
        manager.readTasks(System.in);

        System.out.println("By categories with priority");
        manager.printTasks(System.out, true, true);

        System.out.println("-------------------------");
        System.out.println("By categories without priority");
        manager.printTasks(System.out, false, true);

        System.out.println("-------------------------");
        System.out.println("All tasks without priority");
        manager.printTasks(System.out, false, false);

        System.out.println("-------------------------");
        System.out.println("All tasks with priority");
        manager.printTasks(System.out, true, false);
    }
}

```

**What if? **
- We need to add more types of tasks? e.g `CodingTask`, `ChecklistTask`, `MeetingTask` etc.
- We need to add more properties to the tasks? e.g notifications, reminders, recurrent repetition, completion status, ownership, tags etc.

We would need to write a new class for each type of Task and then on every new feature we would need to modify all the classes. This would violate the Open/Closed principle.

##### Solution with design patterns
```java
//package mk.ukim.finki.primeri;

import java.io.*;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

interface ITask {
    LocalDateTime getDeadline();
    int getPriority();
    String getCategory();
}

class DeadlineNotValidException extends Exception {
    public DeadlineNotValidException(LocalDateTime deadline) {
        super(String.format("The deadline %s has already passed", deadline));
    }
}


class SimpleTask implements ITask {

    String category;
    String name;
    String description;

    public SimpleTask(String category, String name, String description) {
        this.category = category;
        this.name = name;
        this.description = description;
    }

    @Override
    public LocalDateTime getDeadline() {
        return LocalDateTime.MAX;
    }

    @Override
    public int getPriority() {
        return Integer.MAX_VALUE;
    }

    @Override
    public String getCategory() {
        return category;
    }

    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder("Task{");
        sb.append("name='").append(name).append('\'');
        sb.append(", description='").append(description).append('\'');
        sb.append('}');
        return sb.toString();
    }
}

abstract class TaskDecorator implements ITask{
    ITask iTask;

    public TaskDecorator(ITask iTask) {
        this.iTask = iTask;
    }
}

class PriorityTaskDecorator extends TaskDecorator {

    int priority;

    public PriorityTaskDecorator(ITask iTask, int priority) {
        super(iTask);
        this.priority = priority;
    }

    @Override
    public LocalDateTime getDeadline() {
        return iTask.getDeadline();
    }

    @Override
    public int getPriority() {
        return priority;
    }

    @Override
    public String getCategory() {
        return iTask.getCategory();
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(iTask.toString(), 0, iTask.toString().length()-1);
        sb.append(", priority=").append(priority);
        sb.append('}');
        return sb.toString();
    }
}

class TimeTaskDecorator extends TaskDecorator {

    LocalDateTime deadline;

    public TimeTaskDecorator(ITask iTask, LocalDateTime deadline) {
        super(iTask);
        this.deadline = deadline;
    }

    @Override
    public LocalDateTime getDeadline() {
        return deadline;
    }

    @Override
    public int getPriority() {
        return iTask.getPriority();
    }

    @Override
    public String getCategory() {
        return iTask.getCategory();
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(iTask.toString(), 0, iTask.toString().length()-1);
        sb.append(", deadline=").append(deadline);
        sb.append('}');
        return sb.toString();
    }
}

class TaskFactory {
    public static ITask createTask (String line) throws DeadlineNotValidException {
        String [] parts = line.split(",");
        String category = parts[0];
        String name = parts[1];
        String description = parts[2];
        SimpleTask base = new SimpleTask(category, name, description);
        if (parts.length==3) {
            return base;
        } else if (parts.length==4) {
            try {
                int priority = Integer.parseInt(parts[3]);
                return new PriorityTaskDecorator(base, priority);
            }
            catch (Exception e) { //parsing failed, it's a date
                LocalDateTime deadline = LocalDateTime.parse(parts[3]);
                checkDeadline(deadline);
                return new TimeTaskDecorator(base, deadline);
            }
        } else {
            LocalDateTime deadline = LocalDateTime.parse(parts[3]);
            checkDeadline(deadline);
            int priority = Integer.parseInt(parts[4]);
            return new PriorityTaskDecorator(new TimeTaskDecorator(base,deadline), priority);
        }
    }

    private static void checkDeadline (LocalDateTime deadline) throws DeadlineNotValidException {
        if (deadline.isBefore(LocalDateTime.of(2020, 6, 2, 22, 59, 59)))
            throw new DeadlineNotValidException(deadline);
    }
}

class TaskManager {
    Map<String,List<ITask>> tasks;

    public TaskManager() {
        tasks = new TreeMap<>();
    }

    public void readTasks (InputStream inputStream) {
        tasks = new BufferedReader(new InputStreamReader(inputStream))
                .lines()
                .map(line -> {
                    try {
                        return TaskFactory.createTask(line);
                    } catch (DeadlineNotValidException e) {
                        System.out.println(e.getMessage());
                    }
                    return null;
                })
                .filter(Objects::nonNull)
                .collect(Collectors.groupingBy(
                        ITask::getCategory,
                        TreeMap::new,
                        Collectors.toList())
                );
    }

    public void addTask (ITask iTask) {
        tasks.computeIfAbsent(iTask.getCategory(), k -> new ArrayList<>());
        tasks.computeIfPresent(iTask.getCategory(), (k,v) -> {
            v.add(iTask);
            return v;
        });
    }

    public void printTasks(OutputStream os, boolean includePriority, boolean byCategory) {
        PrintWriter pw = new PrintWriter(os);

        Comparator<ITask> priorityComparator = Comparator.comparing(ITask::getPriority).thenComparing(task -> Duration.between(LocalDateTime.now(), task.getDeadline()));
        Comparator<ITask> simpleComparator = Comparator.comparing(task -> Duration.between(LocalDateTime.now(), task.getDeadline()));

        if (byCategory) {
            tasks.forEach((category, t) -> {
                pw.println(category.toUpperCase());
                t.stream().sorted(includePriority ? priorityComparator : simpleComparator).forEach(pw::println);
            });
        }
        else {
            tasks.values().stream()
                    .flatMap(Collection::stream)
                    .sorted(includePriority ? priorityComparator : simpleComparator)
                    .forEach(pw::println);
        }

        pw.flush();
    }
}

public class TasksManagerTest {

    public static void main(String[] args) {
        System.out.println("Tasks reading");
        manager.readTasks(System.in);
        System.out.println("By categories with priority");
        manager.printTasks(System.out, true, true);
        System.out.println("-------------------------");
        System.out.println("By categories without priority");
        manager.printTasks(System.out, false, true);
        System.out.println("-------------------------");
        System.out.println("All tasks without priority");
        manager.printTasks(System.out, false, false);
        System.out.println("-------------------------");
        System.out.println("All tasks with priority");
        manager.printTasks(System.out, true, false);
        System.out.println("-------------------------");

    }
}

```

This solution would be much easier to extend with new features and new types of tasks. Each new feature would be implemented as a new decorator class, without the need to modify existing classes. This adheres to the Open/Closed principle, as classes are open for extension but closed for modification.
For each new type of task, we would just need to create a new class implementing the ITask interface.

### Observer

Observer is a behavioral design pattern that lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they’re observing.

<img src="../img/observer.png">

